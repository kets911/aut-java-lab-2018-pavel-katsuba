package com.epam.lab.pavel_katsuba.vneklasniki.filters;

import com.sun.jersey.core.util.Priority;
import com.sun.jersey.spi.container.ContainerRequest;
import com.sun.jersey.spi.container.ContainerRequestFilter;

import javax.ws.rs.Priorities;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ResourceInfo;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.core.Response;
import javax.ws.rs.ext.Provider;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.List;

//@Secured
@Provider
@Priority(Priorities.AUTHORIZATION)
public class AuthorizationFilter implements javax.ws.rs.container.ContainerRequestFilter {

 @Context
    private HttpServletRequest httpRequest;
    @Context
    private HttpServletResponse httpServletResponse;

    @Context
    private ResourceInfo resourceInfo;

    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        Method method = resourceInfo.getResourceMethod();
        // everybody can access (e.g. user/create or user/authenticate)
        if( !method.isAnnotationPresent( PermitAll.class ) ) {
            // nobody can access
            if( method.isAnnotationPresent( DenyAll.class ) )
            {
                requestContext.abortWith(
                        Response.status(Response.Status.FORBIDDEN).build()
                );
                return;
            }

            // get request headers to extract jwt token
            final MultivaluedMap<String, String> headers = requestContext.getHeaders();
            final List<String> authProperty = headers.get( AUTHORIZATION_PROPERTY );

            // block access if no authorization information is provided
            if( authProperty == null || authProperty.isEmpty() )
            {
                logger.warn("No token provided!");
                requestContext.abortWith(
                        ResponseBuilder.createResponse( Response.Status.UNAUTHORIZED, ACCESS_DENIED )
                );
                return;
            }
            String id = null ;
            String jwt = authProperty.get(0);

            // try to decode the jwt - deny access if no valid token provided
            try {
                id = TokenSecurity.validateJwtToken( jwt );
            } catch ( InvalidJwtException e ) {
                logger.warn("Invalid token provided!");
                requestContext.abortWith(
                        ResponseBuilder.createResponse( Response.Status.UNAUTHORIZED, ACCESS_INVALID_TOKEN )
                );
                return;
            }

            // check if token matches an user token (set in user/authenticate)
            UserDAO userDao = UserDAOFactory.getUserDAO();
            User user = null;
            try {
                user = userDao.getUser( id );
            }
            catch ( UserNotFoundException e ) {
                logger.warn("Token missmatch!");
                requestContext.abortWith(
                        ResponseBuilder.createResponse( Response.Status.UNAUTHORIZED, ACCESS_DENIED )
                );
                return;
            }

            UserSecurity userSecurity = userDao.getUserAuthentication( user.getId() );

            // token does not match with token stored in database - enforce re authentication
            if( !userSecurity.getToken().equals( jwt ) ) {
                logger.warn("Token expired!");
                requestContext.abortWith(
                        ResponseBuilder.createResponse( Response.Status.UNAUTHORIZED, ACCESS_REFRESH )
                );
                return;
            }
            // verify user access from provided roles ("admin", "user", "guest")
            if( method.isAnnotationPresent( RolesAllowed.class ) )
            {
                // get annotated roles
                RolesAllowed rolesAnnotation = method.getAnnotation( RolesAllowed.class );
                Set<String> rolesSet = new HashSet<String>( Arrays.asList( rolesAnnotation.value() ) );

                // user valid?
                if( !isUserAllowed( userSecurity.getRole(), rolesSet ) )
                {
                    logger.warn("User does not have the rights to acces this resource!");
                    requestContext.abortWith(
                            ResponseBuilder.createResponse( Response.Status.UNAUTHORIZED, ACCESS_DENIED )
                    );
                    return;
                }
            }

            // set header param email for user identification in rest service - do not decode jwt twice in rest services
            List<String> idList = new ArrayList<String>();
            idList.add( id );
            headers.put( HEADER_PROPERTY_ID, idList );
        }
    }
}
